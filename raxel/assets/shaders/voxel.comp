#version 450

// Compute workgroup size.
layout(local_size_x = 16, local_size_y = 16) in;

// Output storage image (set = 0, binding = 0)
layout(rgba32f, set = 0, binding = 0) uniform image2D outImage;

#define EPSILON 0.01
#define MAX_DISTANCE 100.0
#define MAX_STEPS 1000
#define RAXEL_VOXEL_CHUNK_SIZE 32
#define RAXEL_MAX_LOADED_CHUNKS 8
#define MAX_RAYS 8

//
// A chunk’s metadata stores its integer coordinates in chunk space and a state value.
//
struct VoxelChunkMeta {
    int x;
    int y;
    int z;
    int state;
};

//
// Each chunk now stores its voxels as a flat array.
// The total number of voxels per chunk is RAXEL_VOXEL_CHUNK_SIZE³.
//
struct VoxelChunk {
    uint voxels[RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE];
};

//
// The GPUVoxelWorld holds up to RAXEL_MAX_LOADED_CHUNKS chunks and their metadata.
//
struct GPUVoxelWorld {
    VoxelChunkMeta chunk_meta[RAXEL_MAX_LOADED_CHUNKS];
    VoxelChunk chunks[RAXEL_MAX_LOADED_CHUNKS];
    uint num_loaded_chunks;
};

// Storage buffer (set = 0, binding = 1) holding the voxel world.
layout(std430, set = 0, binding = 1) buffer VoxelWorldBuffer {
    GPUVoxelWorld voxel_world;
};

// Push constants: view matrix, fov (radians), rays_per_pixel, and debug_mode.
// debug_mode: 0 = normal shaded rendering,
//             1 = depth visualization,
//             2 = raw voxel data display.
layout(push_constant) uniform PC {
    mat4 view;
    float fov;
    int rays_per_pixel;
    int debug_mode;
} pc;

//
// A structure to hold the result of raymarching.
//
struct RaymarchResult {
    vec3 pos;
    vec3 normal;
    float tHit;
    bool hit;
};

//
// Helper function: compute a flat index into the voxel array for a given local coordinate.
//
int flatIndex(int lx, int ly, int lz) {
    return lx + ly * RAXEL_VOXEL_CHUNK_SIZE + lz * RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE;
}

//
// Given a world-space voxel coordinate, look through the loaded chunks to find the voxel value.
// This mimics the CPU function that computes chunk coordinates and local coordinates.
// Voxels with value 0 are treated as air; any non-zero voxel is solid.
//
uint getVoxelAtWorldPos(ivec3 worldPos) {
    for (int i = 0; i < int(voxel_world.num_loaded_chunks); i++) {
        VoxelChunkMeta meta = voxel_world.chunk_meta[i];
        int chunkOriginX = meta.x * RAXEL_VOXEL_CHUNK_SIZE;
        int chunkOriginY = meta.y * RAXEL_VOXEL_CHUNK_SIZE;
        int chunkOriginZ = meta.z * RAXEL_VOXEL_CHUNK_SIZE;
        // Check if the world coordinate lies within this chunk.
        if (worldPos.x >= chunkOriginX && worldPos.x < (chunkOriginX + RAXEL_VOXEL_CHUNK_SIZE) &&
            worldPos.y >= chunkOriginY && worldPos.y < (chunkOriginY + RAXEL_VOXEL_CHUNK_SIZE) &&
            worldPos.z >= chunkOriginZ && worldPos.z < (chunkOriginZ + RAXEL_VOXEL_CHUNK_SIZE)) {
            // Compute local voxel coordinates.
            int localX = worldPos.x - chunkOriginX;
            int localY = worldPos.y - chunkOriginY;
            int localZ = worldPos.z - chunkOriginZ;
            int index = flatIndex(localX, localY, localZ);
            return voxel_world.chunks[i].voxels[index];
        }
    }
    return 0u;
}

//
// Returns true if the voxel at the given world coordinate is solid (non-zero).
//
bool isVoxelSolid(ivec3 worldPos) {
    return getVoxelAtWorldPos(worldPos) != 0u;
}

//
// Returns 1.0 for solid and 0.0 for air. Used when estimating normals.
//
float voxelValue(vec3 pos) {
    ivec3 voxelPos = ivec3(floor(pos));
    return isVoxelSolid(voxelPos) ? 1.0 : 0.0;
}

//
// Estimate a surface normal at a given point using central differences.
// We sample the voxelValue offset by EPSILON along each axis.
//
vec3 estimateNormal(vec3 pos) {
    float dx = voxelValue(pos + vec3(EPSILON, 0.0, 0.0)) - voxelValue(pos - vec3(EPSILON, 0.0, 0.0));
    float dy = voxelValue(pos + vec3(0.0, EPSILON, 0.0)) - voxelValue(pos - vec3(0.0, EPSILON, 0.0));
    float dz = voxelValue(pos + vec3(0.0, 0.0, EPSILON)) - voxelValue(pos - vec3(0.0, 0.0, EPSILON));
    return normalize(vec3(dx, dy, dz));
}

//
// Raymarching function: starting from 'origin' along 'dir', step through space until a solid voxel is hit
// or the maximum distance/steps is reached. On a hit, estimate the surface normal.
//
RaymarchResult raymarch(vec3 origin, vec3 dir) {
    RaymarchResult result;
    result.tHit = 0.0;
    result.hit = false;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 pos = origin + result.tHit * dir;
        if (isVoxelSolid(ivec3(floor(pos)))) {
            result.pos = pos;
            result.hit = true;
            result.normal = estimateNormal(pos);
            break;
        }
        result.tHit += 0.1;
        if (result.tHit > MAX_DISTANCE) {
            break;
        }
    }
    return result;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSizeVec = imageSize(outImage);
    vec4 color = vec4(0.0);

    if (pc.debug_mode == 2) {
        // Debug mode 2: display raw voxel data.
        // use pix as an index into the large array
        int idx = pixelCoord.y * imageSizeVec.x + pixelCoord.x;
        int chunk_idx = idx % RAXEL_MAX_LOADED_CHUNKS;
        int voxel_x = idx % RAXEL_VOXEL_CHUNK_SIZE;
        int voxel_y = (idx / RAXEL_VOXEL_CHUNK_SIZE) % RAXEL_VOXEL_CHUNK_SIZE;
        int voxel_z = (idx / (RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE)) % RAXEL_VOXEL_CHUNK_SIZE;

        uint voxel = voxel_world.chunks[chunk_idx].voxels[flatIndex(voxel_x, voxel_y, voxel_z)];
        color = vec4(float(voxel) / 255.0, 0.0, 0.0, 1.0);

    } else {
        // --- Other Debug Modes: Raymarching ---
        // Map pixel coordinates to normalized device coordinates (range [-1, 1]).
        vec2 uv = (vec2(pixelCoord) / vec2(imageSizeVec)) * 2.0 - 1.0;
        float aspect = float(imageSizeVec.x) / float(imageSizeVec.y);
        uv.x *= aspect;

        // Compute the ray direction by applying the fov and view matrix.
        float tanFov = tan(pc.fov * 0.5);
        vec3 rayDir = normalize((pc.view * vec4(uv.x * tanFov, uv.y * tanFov, -1.0, 0.0)).xyz);
        // Assume the camera is located at the origin in view space.
        vec3 rayOrigin = (pc.view * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

        RaymarchResult result = raymarch(rayOrigin, rayDir);

        if (pc.debug_mode == 0) {
            // Normal shaded rendering using simple diffuse lighting.
            if (result.hit) {
                vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
                float diff = max(dot(result.normal, lightDir), 0.0);
                color = vec4(vec3(diff), 1.0);
            } else {
                color = vec4(0.0);
            }
        } else if (pc.debug_mode == 1) {
            // Depth visualization: grayscale based on hit distance.
            float depth = result.hit ? result.tHit / MAX_DISTANCE : 1.0;
            color = vec4(vec3(depth), 1.0);
        }
    }

    imageStore(outImage, pixelCoord, color);
}

#version 450

// Output storage image (set = 0, binding = 0)
layout(rgba32f, set = 0, binding = 0) uniform image2D outImage;

// Compute workgroup size.
layout(local_size_x = 16, local_size_y = 16) in;

// -----------------------------------------------------------------------------
// Macros
// -----------------------------------------------------------------------------
#define RAXEL_VOXEL_CHUNK_SIZE 32
#define RAXEL_MAX_LOADED_CHUNKS 32
#define RAXEL_BVH_MAX_NODES 4096
#define EPSILON 0.01
#define MAX_DISTANCE 1000.0
#define MAX_STEPS 1000

// -----------------------------------------------------------------------------
// Voxel World Structures
// -----------------------------------------------------------------------------
struct VoxelChunkMeta {
    int x;
    int y;
    int z;
    int state;
};

struct VoxelChunk {
    uint voxels[RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE];
};

// -----------------------------------------------------------------------------
// BVH Structures
// -----------------------------------------------------------------------------
struct BVHNode {
    vec3 bounds_min;
    vec3 bounds_max;
    // For leaf nodes, child_offset holds the first primitive offset.
    // For interior nodes, child_offset holds the index of the second child.
    int child_offset;
    uint n_primitives;  // if >0 then leaf; if 0 then interior
    uint axis;          // valid for interior nodes
};

struct BVHAccel {
    BVHNode nodes[RAXEL_BVH_MAX_NODES];
    int n_nodes;
    int max_leaf_size;
};

// -----------------------------------------------------------------------------
// Combined GPU Voxel World Structure
// -----------------------------------------------------------------------------
struct GPUVoxelWorld {
    BVHAccel bvh;
    uint num_loaded_chunks;
    VoxelChunkMeta chunk_meta[RAXEL_MAX_LOADED_CHUNKS];
    VoxelChunk chunks[RAXEL_MAX_LOADED_CHUNKS];
};

// -----------------------------------------------------------------------------
// Uniform Buffer: Voxel World Data
// -----------------------------------------------------------------------------
layout(std430, set = 0, binding = 1) buffer VoxelWorldBuffer {
    GPUVoxelWorld voxel_world;
};

// -----------------------------------------------------------------------------
// Push Constants
// -----------------------------------------------------------------------------
layout(push_constant) uniform PC {
    mat4 view;
    float fov;
    int rays_per_pixel;
    int debug_mode;
} pc;



// -----------------------------------------------------------------------------
// Utility Functions
// -----------------------------------------------------------------------------
int flatIndex(int lx, int ly, int lz) {
    return lx + ly * RAXEL_VOXEL_CHUNK_SIZE + lz * RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE;
}

// Slab-based AABB intersection; outputs tmin and tmax.
bool intersectAABB(vec3 ro, vec3 rd, vec3 inv_rd, vec3 bmin, vec3 bmax, out float tmin, out float tmax) {
    vec3 t0 = (bmin - ro) * inv_rd;
    vec3 t1 = (bmax - ro) * inv_rd;
    vec3 tsmaller = min(t0, t1);
    vec3 tbigger = max(t0, t1);
    tmin = max(max(tsmaller.x, tsmaller.y), tsmaller.z);
    tmax = min(min(tbigger.x, tbigger.y), tbigger.z);
    return tmax >= max(tmin, 0.0);
}

// -----------------------------------------------------------------------------
// BVH Traversal Function
// -----------------------------------------------------------------------------
bool traverseBVH(vec3 ro, vec3 rd, out float t_hit) {
    vec3 inv_rd = 1.0 / rd;
    int stack[64];
    int stack_ptr = 0;
    stack[stack_ptr++] = 0; // Start at root (index 0)
    bool hit_found = false;
    t_hit = 1e30;
    
    while (stack_ptr > 0) {
        int node_index = stack[--stack_ptr];
        if (node_index < 0 || node_index >= voxel_world.bvh.n_nodes)
            continue;
        BVHNode node = voxel_world.bvh.nodes[node_index];
        float tmin, tmax;
        if (!intersectAABB(ro, rd, inv_rd, node.bounds_min, node.bounds_max, tmin, tmax))
            continue;
        if (node.n_primitives > 0) {
            // For voxel primitives, we use tmin as hit distance.
            if (tmin < t_hit) {
                t_hit = tmin;
                hit_found = true;
            }
        } else {
            // Interior node: push children.
            // In our layout, the first child is assumed to be immediately next,
            // and the second child is stored at node.child_offset.
            stack[stack_ptr++] = node_index + 1;
            stack[stack_ptr++] = node.child_offset;
        }
    }
    return hit_found;
}

// -----------------------------------------------------------------------------
// Voxel Query Functions
// -----------------------------------------------------------------------------
uint getVoxelAtWorldPos(ivec3 worldPos) {
    for (int i = 0; i < int(voxel_world.num_loaded_chunks); i++) {
        VoxelChunkMeta meta = voxel_world.chunk_meta[i];
        int chunkOriginX = meta.x * RAXEL_VOXEL_CHUNK_SIZE;
        int chunkOriginY = meta.y * RAXEL_VOXEL_CHUNK_SIZE;
        int chunkOriginZ = meta.z * RAXEL_VOXEL_CHUNK_SIZE;
        if (worldPos.x >= chunkOriginX && worldPos.x < (chunkOriginX + RAXEL_VOXEL_CHUNK_SIZE) &&
            worldPos.y >= chunkOriginY && worldPos.y < (chunkOriginY + RAXEL_VOXEL_CHUNK_SIZE) &&
            worldPos.z >= chunkOriginZ && worldPos.z < (chunkOriginZ + RAXEL_VOXEL_CHUNK_SIZE)) {
            int localX = worldPos.x - chunkOriginX;
            int localY = worldPos.y - chunkOriginY;
            int localZ = worldPos.z - chunkOriginZ;
            int index = flatIndex(localX, localY, localZ);
            return voxel_world.chunks[i].voxels[index];
        }
    }
    return 0u;
}

bool isVoxelSolid(ivec3 worldPos) {
    return getVoxelAtWorldPos(worldPos) != 0u;
}

float voxelValue(vec3 pos) {
    ivec3 voxelPos = ivec3(floor(pos));
    return isVoxelSolid(voxelPos) ? 1.0 : 0.0;
}

vec3 estimateNormal(vec3 pos) {
    float eps = 0.01;
    float dx = voxelValue(pos + vec3(eps, 0.0, 0.0)) - voxelValue(pos - vec3(eps, 0.0, 0.0));
    float dy = voxelValue(pos + vec3(0.0, eps, 0.0)) - voxelValue(pos - vec3(0.0, eps, 0.0));
    float dz = voxelValue(pos + vec3(0.0, 0.0, eps)) - voxelValue(pos - vec3(0.0, 0.0, eps));
    return normalize(vec3(dx, dy, dz));
}

// -----------------------------------------------------------------------------
// Raymarching using BVH Traversal
// -----------------------------------------------------------------------------
struct RaymarchResult {
    vec3 pos;
    vec3 normal;
    float tHit;
    bool hit;
};

RaymarchResult raymarch(vec3 ro, vec3 rd) {
    RaymarchResult result;
    result.hit = false;
    result.tHit = 0.0;
    float t;
    if (traverseBVH(ro, rd, t)) {
        result.hit = true;
        result.tHit = t;
        result.pos = ro + t * rd;
        float eps = 0.01;
        float dx = (isVoxelSolid(ivec3(result.pos + vec3(eps, 0.0, 0.0))) ? 1.0 : 0.0) -
                   (isVoxelSolid(ivec3(result.pos - vec3(eps, 0.0, 0.0))) ? 1.0 : 0.0);
        float dy = (isVoxelSolid(ivec3(result.pos + vec3(0.0, eps, 0.0))) ? 1.0 : 0.0) -
                   (isVoxelSolid(ivec3(result.pos - vec3(0.0, eps, 0.0))) ? 1.0 : 0.0);
        float dz = (isVoxelSolid(ivec3(result.pos + vec3(0.0, 0.0, eps))) ? 1.0 : 0.0) -
                   (isVoxelSolid(ivec3(result.pos - vec3(0.0, 0.0, eps))) ? 1.0 : 0.0);
        result.normal = normalize(vec3(dx, dy, dz));
    }
    return result;
}

// -----------------------------------------------------------------------------
// Main Shader Entry
// -----------------------------------------------------------------------------
void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSizeVec = imageSize(outImage);
    vec4 color = vec4(0.0);

    if (pc.debug_mode == 2) {
        // Debug mode 2: display raw voxel data.
        int idx = pixelCoord.y * imageSizeVec.x + pixelCoord.x;
        int chunk_idx = idx % RAXEL_MAX_LOADED_CHUNKS;
        int voxel_x = idx % RAXEL_VOXEL_CHUNK_SIZE;
        int voxel_y = (idx / RAXEL_VOXEL_CHUNK_SIZE) % RAXEL_VOXEL_CHUNK_SIZE;
        int voxel_z = (idx / (RAXEL_VOXEL_CHUNK_SIZE * RAXEL_VOXEL_CHUNK_SIZE)) % RAXEL_VOXEL_CHUNK_SIZE;
        uint voxel = voxel_world.chunks[chunk_idx].voxels[flatIndex(voxel_x, voxel_y, voxel_z)];
        color = vec4(float(voxel) / 255.0, 0.0, float(chunk_idx) / float(RAXEL_MAX_LOADED_CHUNKS), 1.0);
    } else {
        // Raymarching mode using BVH.
        mat4 invView = inverse(pc.view);
        vec2 uv = (vec2(pixelCoord) / vec2(imageSizeVec)) * 2.0 - 1.0;
        float aspect = float(imageSizeVec.x) / float(imageSizeVec.y);
        uv.x *= aspect;
        float tanFov = tan(pc.fov * 0.5);
        vec3 rayOrigin = (invView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
        vec3 rayDir = normalize((invView * vec4(uv.x * tanFov, uv.y * tanFov, -1.0, 0.0)).xyz);
        RaymarchResult result = raymarch(rayOrigin, rayDir);
        if (pc.debug_mode == 0) {
            if (result.hit) {
                vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
                float diff = max(dot(result.normal, lightDir), 0.0);
                color = vec4(vec3(diff), 1.0);
            } else {
                color = vec4(0.0);
            }
        } else if (pc.debug_mode == 1) {
            float depth = result.hit ? result.tHit / MAX_DISTANCE : 1.0;
            color = vec4(vec3(depth), 1.0);
        }
    }
    imageStore(outImage, pixelCoord, color);
}

#version 450

// Compute workgroup size.
layout(local_size_x = 16, local_size_y = 16) in;

// Output storage image (set = 0, binding = 0)
layout(rgba32f, set = 0, binding = 0) uniform image2D outImage;

#define EPSILON 0.001
#define MAX_DISTANCE 100.0
#define MAX_STEPS 256
#define RAXEL_VOXEL_CHUNK_SIZE 32
#define RAXEL_MAX_LOADED_CHUNKS 8
#define MAX_RAYS 8

struct VoxelChunkMeta {
    int x;
    int y;
    int z;
    int state;
};

struct VoxelChunk {
    uint voxels[RAXEL_VOXEL_CHUNK_SIZE][RAXEL_VOXEL_CHUNK_SIZE][RAXEL_VOXEL_CHUNK_SIZE];
};

struct GPUVoxelWorld {
    VoxelChunkMeta chunk_meta[RAXEL_MAX_LOADED_CHUNKS];
    VoxelChunk chunks[RAXEL_MAX_LOADED_CHUNKS];
    uint num_loaded_chunks;
};

// Storage buffer (set = 0, binding = 1) holding the voxel world.
layout(std430, set = 0, binding = 1) buffer VoxelWorldBuffer {
    GPUVoxelWorld voxel_world;
};

// Push constants: view matrix, fov (radians), rays_per_pixel, and debug_mode.
// debug_mode: 0 = normal, 1 = SDF debug, 2 = display raw voxel data.
layout(push_constant) uniform PC {
    mat4 view;
    float fov;
    int rays_per_pixel;
    int debug_mode;
} pc;

//
// Sample the voxel world at a given world position.
// Returns the voxel material value (0 means air).
//
uint sampleVoxelWorld(vec3 pos) {
    for (int i = 0; i < RAXEL_MAX_LOADED_CHUNKS; i++) {
        if (i >= int(voxel_world.num_loaded_chunks))
            continue;
        vec3 chunkOrigin = vec3(voxel_world.chunk_meta[i].x,
                                voxel_world.chunk_meta[i].y,
                                voxel_world.chunk_meta[i].z) * float(RAXEL_VOXEL_CHUNK_SIZE);
        vec3 relPos = pos - chunkOrigin;
        if (all(greaterThanEqual(relPos, vec3(0.0))) &&
            all(lessThan(relPos, vec3(float(RAXEL_VOXEL_CHUNK_SIZE))))) {
            ivec3 idx = ivec3(relPos);
            return voxel_world.chunks[i].voxels[idx.x][idx.y][idx.z];
        }
    }
    return 0u;
}

//
// Voxel world SDF function.
// If a voxel is present (nonzero), returns a small negative value (hit),
// otherwise returns a positive value estimated from the fractional part of pos.
//
float sdfVoxelWorld(vec3 pos) {
    uint voxel = sampleVoxelWorld(pos);
    if (voxel > 0u) {
        return -EPSILON;
    }
    vec3 f = fract(pos);
    float d = min(min(f.x, 1.0 - f.x), min(f.y, 1.0 - f.y));
    d = min(d, min(f.z, 1.0 - f.z));
    return d;
}

//
// Estimate normal at position pos via finite differences.
//
vec3 estimateNormal(vec3 pos) {
    float dx = sdfVoxelWorld(pos + vec3(EPSILON, 0, 0)) - sdfVoxelWorld(pos - vec3(EPSILON, 0, 0));
    float dy = sdfVoxelWorld(pos + vec3(0, EPSILON, 0)) - sdfVoxelWorld(pos - vec3(0, EPSILON, 0));
    float dz = sdfVoxelWorld(pos + vec3(0, 0, EPSILON)) - sdfVoxelWorld(pos - vec3(0, 0, EPSILON));
    return normalize(vec3(dx, dy, dz));
}

//
// Raymarch function: marches along rd from ro until a hit (sdf < EPSILON)
// or max distance is reached. Returns a RaymarchResult structure.
//
struct RaymarchResult {
    vec3 pos;
    vec3 normal;
    float tHit;
    bool hit;
};

RaymarchResult raymarch(vec3 ro, vec3 rd) {
    RaymarchResult res;
    res.hit = false;
    float t = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 pos = ro + rd * t;
        float d = sdfVoxelWorld(pos);
        if (d < EPSILON) {
            res.hit = true;
            res.tHit = t;
            res.pos = pos;
            res.normal = estimateNormal(pos);
            return res;
        }
        t += d;
        if (t > MAX_DISTANCE)
            break;
    }
    res.tHit = t;
    res.pos = ro + rd * t;
    res.normal = vec3(0.0);
    return res;
}

//
// Main entry: cast multiple rays per pixel and average the result.
// In debug mode 1, output SDF value at ray origin.
// In debug mode 2, display raw voxel data from the first chunk.
//
void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    vec2 iResolution = vec2(800.0, 600.0);
    if (pix.x >= int(iResolution.x) || pix.y >= int(iResolution.y))
        return;
    
    vec3 final_color = vec3(0.0);
    int valid_rays = 0;

    int rays_per_pixel = pc.rays_per_pixel;
    
    for (int r = 0; r < MAX_RAYS; r++) {
        if (r >= rays_per_pixel)
            break;
        
        // Jitter the pixel UV slightly.
        vec2 jitter = vec2(fract(float(r) * 12.34), fract(float(r) * 56.78));
        vec2 uv = (vec2(pix) + jitter) / iResolution;
        vec2 ndc = (uv - 0.5) * 2.0;
        ndc.x *= iResolution.x / iResolution.y;
        
        float half_fov = pc.fov * 0.5;
        vec3 rd_cam = normalize(vec3(ndc * tan(half_fov), -1.0));
        
        // Transform to world space.
        mat4 inv_view = inverse(pc.view);
        vec3 ro = (inv_view * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
        vec3 rd = normalize((inv_view * vec4(rd_cam, 0.0)).xyz);
        rd.y = -rd.y;
        
        // Normal raymarching.
        RaymarchResult rr = raymarch(ro, rd);
        vec3 col = vec3(0.0);
        
        if (pc.debug_mode == 1) {
            // Debug mode 1: output SDF value at ray origin as grayscale.
            float d = sdfVoxelWorld(ro);
            col = vec3(clamp(d, 0.0, 1.0));
        } else if (pc.debug_mode == 2) {
            // Debug mode 2: display raw voxel data.
            // use pix as an index into the large array
            int idx = pix.x + pix.y * int(iResolution.x);
            uint voxel = sampleVoxelWorld(vec3(float(idx), 0.0, 0.0));
            col = vec3(float(voxel) / 255.0);
        } else {
            // Normal mode.
            if (rr.hit) {
                // Use the estimated normal for shading.
                col = rr.normal * 0.5 + 0.5;
            }
        }
        
        final_color += col;
        valid_rays++;
    }
    
    if (valid_rays > 0)
        final_color /= float(valid_rays);
    
    imageStore(outImage, pix, vec4(final_color, 1.0));
}

#version 450

// Define a workgroup size.
layout(local_size_x = 16, local_size_y = 16) in;

// Binding for the output image (set 0, binding 0).
layout(rgba32f, set = 0, binding = 0) uniform image2D outImage;

// Push constant block containing a view matrix, fov, and rays_per_pixel.
layout(push_constant) uniform PushConstants {
    mat4 view;
    float fov;
    int rays_per_pixel;
} pc;

// Storage buffer for the voxel world data.
// Here we assume the voxel world is flattened into an array of unsigned ints.
layout(std430, set = 0, binding = 1) buffer VoxelWorldBuffer {
    uint voxels[];
};

//
// Helper: a dummy function to sample the voxel world.
// In a real application, you’d convert a world-space position to voxel indices and then sample voxel data.
// Here, for demonstration, we just use one component of the position to index into the voxel buffer.
//
uint sampleVoxel(vec3 pos) {
    // For simplicity, use the x-coordinate scaled into an index.
    // Assume the buffer has at least 1024 elements.
    uint index = uint(abs(pos.x * 10.0)) % 1024;
    return voxels[index];
}

//
// Simple raymarching loop.
// We fire rays from a fixed origin (e.g. the camera position, which you could embed in the view matrix)
// and test for a hit when the y-component drops below zero (as a dummy surface).
//
void main() {
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(outImage);
    vec2 uv = vec2(coords) / vec2(imgSize);
    
    // Compute a simple perspective ray direction.
    float aspect = float(imgSize.x) / float(imgSize.y);
    // Map uv from [0,1] to [-1,1].
    vec2 ndc = (uv - 0.5) * 2.0;
    ndc.x *= aspect;
    
    // Assume the ray origin is at (0,0,0) in view space.
    vec3 rayOrigin = vec3(0.0);
    vec3 rayDir = normalize(vec3(ndc, 1.0));
    // Transform the ray direction by the view matrix.
    rayDir = (pc.view * vec4(rayDir, 0.0)).xyz;
    
    vec3 finalColor = vec3(0.0);
    // Accumulate color over several rays per pixel.
    for (int i = 0; i < pc.rays_per_pixel; i++) {
        // For slight randomness per ray, add a small offset.
        vec3 offset = vec3(float(i) / float(pc.rays_per_pixel)) * 0.001;
        vec3 dir = normalize(rayDir + offset);
        
        // Simple raymarch loop.
        float t = 0.0;
        bool hit = false;
        vec3 col = vec3(0.0);
        for (int step = 0; step < 100; step++) {
            vec3 pos = rayOrigin + t * dir;
            // For demonstration, we “hit” when pos.y goes below zero.
            if (pos.y < 0.0) {
                // Use the sampled voxel value to modulate color.
                uint voxelVal = sampleVoxel(pos);
                float intensity = float(voxelVal) / 255.0;
                col = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), intensity);
                hit = true;
                break;
            }
            t += 0.1;
        }
        // If no hit, use sky-blue.
        if (!hit) {
            col = vec3(0.0, 0.5, 1.0);
        }
        finalColor += col;
    }
    
    finalColor /= float(pc.rays_per_pixel);
    imageStore(outImage, coords, vec4(finalColor, 1.0));
}

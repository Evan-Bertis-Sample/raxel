#version 450
layout(local_size_x = 16, local_size_y = 16) in;

// We'll bind our image at set=0, binding=0.
layout(rgba32f, set = 0, binding = 0) uniform image2D outputImage;

const vec2 iResolution = vec2(800.0, 600.0);

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if(pix.x >= int(iResolution.x) || pix.y >= int(iResolution.y)) {
        return;
    }

    // Convert pixel coords to normalized [-1..1] range:
    vec2 uv = (vec2(pix) + 0.5) / iResolution * 2.0 - 1.0;
    // Adjust for aspect ratio (800 x 600):
    uv.x *= iResolution.x / iResolution.y;

    float radius = 0.3;

    // Distance from center of screen:
    float distCenter = length(uv) - radius;

    // We'll sample a little bit to the right and up to approximate derivatives:
    // Note: dx, dy in uv-space ~ 1 / iResolution, but we also adjusted uv.x by aspect ratio,
    // so let's keep it consistent. We just do it in screen-space for simplicity.
    vec2 dPix = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);
    // After adjusting for aspect ratio, moving one pixel in x is scaled:
    vec2 dPixX = vec2(dPix.x * iResolution.x / iResolution.y, 0.0);
    vec2 dPixY = vec2(0.0, dPix.y);

    float distRight = length(uv + dPixX) - radius;
    float distUp = length(uv + dPixY) - radius;

    float ddx = distRight - distCenter;
    float ddy = distUp - distCenter;
    float gradient = sqrt(ddx * ddx + ddy * ddy);

    // We'll define an "edge width" for antialiasing:
    float edge = gradient * 2.0; // tune as you like

    // Use smoothstep around zero distance
    // distCenter < 0 => inside circle, distCenter > 0 => outside circle
    float alpha = smoothstep(-edge, edge, distCenter);

    // Inside circle = black, outside circle = white
    vec3 color = mix(vec3(0.0), vec3(1.0), alpha);

    imageStore(outputImage, pix, vec4(color, 1.0));
}

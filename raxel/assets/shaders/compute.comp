#version 450
layout(local_size_x = 16, local_size_y = 16) in;

// Our storage image for output (set=0, binding=0).
layout(rgba32f, set = 0, binding = 0) uniform image2D outImage;

// Push constant block with a 4x4 matrix + a float FOV
layout(push_constant) uniform PC {
    mat4 view;  // camera->world transform
    float fov;  // field-of-view in radians
} pc;

struct RaymarchMaterial {
    vec3 color;
    float roughness;
    float metallic;
    float ior;
};

// A struct to represent raymarching results
struct RaymarchResult {
    vec3 pos;   // hit position
    vec3 normal; // hit normal
    float tHit; // distance to hit point
    bool hit;   // true if hit something
    RaymarchMaterial material;
};

// Hard-coded resolution to match your window:
const vec2 iResolution = vec2(800.0, 600.0);

// Simple sphere SDF at origin with radius=1
float sphereSDF(vec3 p) {
    return length(p) - 1.0;
}

const vec3 LIGHT_POS = vec3(0, 5, 0);

// Raymarch parameters
const float EPSILON = 0.001;
const float MAX_DISTANCE = 100.0;
const int MAX_STEPS = 64;


// A naive raymarch for a single sphere at the origin
RaymarchResult raymarchSphere(in vec3 ro, in vec3 rd) {
    float t = 0.0;
    RaymarchResult res;
    res.hit = false;

    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 pos = ro + rd * t;
        float dist = sphereSDF(pos);
        if(dist < EPSILON) {
            res.hit = true;
            res.pos = pos;
            res.normal = normalize(pos);
            res.tHit = t;
            return res;
        }
        t += dist;
        if(t > MAX_DISTANCE) {
            break;
        }
    }
    return res;
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if(pix.x >= int(iResolution.x) || pix.y >= int(iResolution.y)) {
        return; // out of bounds
    }

    // Convert pixel coords to [-1..1], adjusting for aspect ratio
    vec2 uv = (vec2(pix) + 0.5) / iResolution * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;

    // Construct a camera-space ray direction with perspective
    // We'll assume negative Z is forward in camera space
    float halfFov = pc.fov * 0.5;
    vec3 rdCam = normalize(vec3(uv * tan(halfFov), -1.0));

    // Invert the view matrix to transform from camera space to world space
    mat4 invView = inverse(pc.view);

    // Camera origin (0,0,0 in camera space -> world space)
    vec3 ro = (invView * vec4(0, 0, 0, 1)).xyz;
    // Ray direction (rdCam in camera space -> world direction)
    vec3 rd = normalize((invView * vec4(rdCam, 0)).xyz);

    // Raymarch the sphere
    float tHit;
    RaymarchResult res = raymarchSphere(ro, rd);

    // If we hit the sphere, calculate lighting
    vec4 color = vec4(0.0);
    if(res.hit) {
        vec3 lightDir = normalize(LIGHT_POS - res.pos);
        float NdotL = dot(res.normal, lightDir);
        color = vec4(res.normal, 1.0);
    }

    // Write the pixel color to the output image
    imageStore(outImage, pix, color);
}

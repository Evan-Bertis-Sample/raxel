#version 450
layout(local_size_x = 16, local_size_y = 16) in;

// Our storage image for output (set=0, binding=0).
layout(rgba32f, set = 0, binding = 0) uniform image2D outImage;

// Push constant block with a 4x4 matrix + a float FOV
layout(push_constant) uniform PC {
    mat4 view;  // camera->world transform
    float fov;  // field-of-view in radians
} pc;

struct RaymarchMaterial {
    vec3 color;
    float roughness;
    float metallic;
    float ior;
};

// A struct to represent raymarching results
struct RaymarchResult {
    vec3 pos;   // hit position
    vec3 normal; // hit normal
    float tHit; // distance to hit point
    bool hit;   // true if hit something
    RaymarchMaterial material;
};

struct SphereSDF {
    vec3 center;
    float radius;
    RaymarchMaterial material;
};

// Hard-coded resolution to match your window:
const vec2 iResolution = vec2(800.0, 600.0);


const vec3 LIGHT_POS = vec3(0, 5, 0);

// Raymarch parameters
const float EPSILON = 0.001;
const float MAX_DISTANCE = 100.0;
const int MAX_STEPS = 64;


// A naive raymarch for a single sphere at the origin
RaymarchResult raymarchSphere(SphereSDF sphere, vec3 ro, vec3 rd) {
    float t = 0.0;
    RaymarchResult res;
    res.hit = false;
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 pos = ro + rd * t;
        float dist = length(pos - sphere.center) - sphere.radius;
        if(dist < EPSILON) {
            res.hit = true;
            res.pos = pos;
            res.normal = normalize(pos - sphere.center);
            res.tHit = t;
            res.material = sphere.material;
            break;
        }
        t += dist;
        if(t > MAX_DISTANCE) {
            break;
        }
    }

    return res;
}

// description of our scene, a list of spheres
SphereSDF spheres[2] = SphereSDF[](
    SphereSDF(vec3(0, 0, -5), 1.0, RaymarchMaterial(vec3(1, 0, 0), 0.1, 0.0, 1.5)),
    SphereSDF(vec3(0, 0, -10), 2.0, RaymarchMaterial(vec3(0, 1, 0), 0.1, 0.0, 1.5))
);

const int NUM_SPHERES = 2;

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if(pix.x >= int(iResolution.x) || pix.y >= int(iResolution.y)) {
        return; // out of bounds
    }

    // Convert pixel coords to [-1..1], adjusting for aspect ratio
    vec2 uv = (vec2(pix) + 0.5) / iResolution * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;

    // Construct a camera-space ray direction with perspective
    // We'll assume negative Z is forward in camera space
    float halfFov = pc.fov * 0.5;
    vec3 rdCam = normalize(vec3(uv * tan(halfFov), -1.0));

    // Invert the view matrix to transform from camera space to world space
    mat4 invView = inverse(pc.view);

    // Camera origin (0,0,0 in camera space -> world space)
    vec3 ro = (invView * vec4(0, 0, 0, 1)).xyz;
    // Ray direction (rdCam in camera space -> world direction)
    vec3 rd = normalize((invView * vec4(rdCam, 0)).xyz);

    // Raymarch the scene
    RaymarchResult res;
    res.hit = false;
    for(int i = 0; i < NUM_SPHERES; i++) {
        RaymarchResult thisRes = raymarchSphere(spheres[i], ro, rd);

        if(thisRes.hit && (!res.hit || thisRes.tHit < res.tHit)) {
            res = thisRes;
        }
    }

    vec4 color;
    if(res.hit) {
        // Simple Lambertian shading
        vec3 lightDir = normalize(LIGHT_POS - res.pos);
        float NdotL = max(0.0, dot(res.normal, lightDir));
        color = vec4(res.material.color * NdotL, 1.0);
    } else {
        color = vec4(0.0, 0.0, 0.0, 1.0);
    }

    // Write the pixel color to the output image
    imageStore(outImage, pix, color);
}

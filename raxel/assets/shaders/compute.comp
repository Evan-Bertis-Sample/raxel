#version 450
layout(local_size_x = 16, local_size_y = 16) in;

// Our storage image for output (set=0, binding=0).
layout(rgba32f, set = 0, binding = 0) uniform image2D outImage;

// Push constant block with a 4x4 matrix + a float FOV
layout(push_constant) uniform PC {
    mat4 view;  // camera->world transform
    float fov;  // field-of-view in radians
} pc;

struct RaymarchMaterial {
    vec3 color;
    float roughness;
    float metallic;
    float ior;
};

// A struct to represent raymarching results
struct RaymarchResult {
    vec3 pos;   // hit position
    vec3 normal; // hit normal
    float tHit; // distance to hit point
    bool hit;   // true if hit something
    RaymarchMaterial material;
};

struct SphereSDF {
    vec3 center;
    float radius;
    RaymarchMaterial material;
};

struct CubeSDF {
    mat4 transform;
    RaymarchMaterial material;
};

struct Light {
    vec3 position;
    vec3 color;
    float intensity;
    int lightType; // 0 = point, 1 = directional
    int attenuationType; // 0 = none, 1 = linear, 2 = quadratic
};


// description of our scene
SphereSDF spheres[3] = SphereSDF[](
    SphereSDF(vec3(0, 0, -5), 1.0, RaymarchMaterial(vec3(1, 0, 0), 0.1, 0.0, 1.5)), 
    SphereSDF(vec3(1, 0, -10), 2.0, RaymarchMaterial(vec3(0, 1, 0), 0.1, 0.0, 1.5)), 
    SphereSDF(vec3(-1, 0, -15), 3.0, RaymarchMaterial(vec3(0, 0, 1), 0.1, 0.0, 1.5)));

const int NUM_SPHERES = 3;

CubeSDF cubes[1] = CubeSDF[](CubeSDF(mat4(vec4(1, 0, 0, 0), vec4(0, 1, 0, 0), vec4(0, 0, 1, -20), vec4(0, 0, 0, 1)), RaymarchMaterial(vec3(1, 1, 1), 0.1, 0.0, 1.5)));

const int NUM_CUBES = 0;

// Light description
Light lights[2] = Light[](
    Light(vec3(0, 1, -2), vec3(1, 1, 1), 1.0, 0, 2), // point light
    Light(vec3(1, 1, -1), vec3(0.4, 0.53, 0.87), 0.25, 1, 0) // directional light
);
const int NUM_LIGHTS = 2;

// Hard-coded resolution to match your window:
const vec2 iResolution = vec2(800.0, 600.0);

// Raymarch parameters
const float EPSILON = 0.001;
const float MAX_DISTANCE = 100.0;
const int MAX_STEPS = 64;

// A naive raymarch for a single sphere at the origin
RaymarchResult raymarchSphere(SphereSDF sphere, vec3 ro, vec3 rd) {
    float t = 0.0;
    RaymarchResult res;
    res.hit = false;
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 pos = ro + rd * t;
        float dist = length(pos - sphere.center) - sphere.radius;
        if(dist < EPSILON) {
            res.hit = true;
            res.pos = pos;
            res.normal = normalize(pos - sphere.center);
            res.tHit = t;
            res.material = sphere.material;
            break;
        }
        t += dist;
        if(t > MAX_DISTANCE) {
            break;
        }
    }

    return res;
}

RaymarchResult raymarchCube(CubeSDF cube, vec3 ro, vec3 rd) {
    float t = 0.0;
    RaymarchResult res;
    res.hit = false;
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 pos = ro + rd * t;
        vec3 posLocal = (inverse(cube.transform) * vec4(pos, 1)).xyz;
        float dist = length(max(abs(posLocal) - vec3(1.0), 0.0)) - 0.5;
        if(dist < EPSILON) {
            res.hit = true;
            res.pos = pos;
            res.normal = normalize(pos - cube.transform[3].xyz);
            res.tHit = t;
            res.material = cube.material;
            break;
        }
        t += dist;
        if(t > MAX_DISTANCE) {
            break;
        }
    }

    return res;
}

vec4 calculateLightColor(RaymarchResult res, Light light, vec3 lightDir) {
    vec3 viewDir = normalize(-res.pos);
    vec3 halfwayDir = normalize(lightDir + viewDir);

    float NdotL = max(0.0, dot(res.normal, lightDir));
    float NdotH = max(0.0, dot(res.normal, halfwayDir));
    float VdotH = max(0.0, dot(viewDir, halfwayDir));

    vec3 ambient = light.color * light.intensity;
    vec3 diffuse = light.color * light.intensity * NdotL;
    vec3 specular = light.color * light.intensity * pow(NdotH, 32.0);

    return vec4(ambient + diffuse + specular, 1.0);
}

vec4 calculateDirectionalLightColor(RaymarchResult res, Light light) {
    vec3 lightDir = normalize(-light.position);

    return calculateLightColor(res, light, lightDir);
}

float calculateAttenuationFactor(Light light, float distance) {
    float none = 1.0;
    float linear = 1.0 / distance;
    float quadratic = 1.0 / (distance * distance);

    // linear combination of attenuation types, no branching
    return none * float(light.attenuationType == 0) +
        linear * float(light.attenuationType == 1) +
        quadratic * float(light.attenuationType == 2);
}

vec4 calculatePointLightColor(RaymarchResult res, Light light) {
    vec3 lightDir = normalize(light.position - res.pos);
    float distance = length(light.position - res.pos);
    float attenuation = calculateAttenuationFactor(light, distance);

    return calculateLightColor(res, light, lightDir) * attenuation;
}

vec4 calculateLightColor(RaymarchResult res, Light light) {
    vec4 pointLight = calculatePointLightColor(res, light) * vec4(res.material.color, 1.0);
    vec4 directionalLight = calculateDirectionalLightColor(res, light) * vec4(res.material.color, 1.0);

    // linear combination of light types, no branching
    return pointLight * float(light.lightType == 0) +
        directionalLight * float(light.lightType == 1);
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if(pix.x >= int(iResolution.x) || pix.y >= int(iResolution.y)) {
        return; // out of bounds
    }

    // Convert pixel coords to [-1..1], adjusting for aspect ratio
    vec2 uv = (vec2(pix) + 0.5) / iResolution * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;

    // Construct a camera-space ray direction with perspective
    // We'll assume negative Z is forward in camera space
    float halfFov = pc.fov * 0.5;
    vec3 rdCam = normalize(vec3(uv * tan(halfFov), -1.0));

    // Invert the view matrix to transform from camera space to world space
    mat4 invView = inverse(pc.view);

    // Camera origin (0,0,0 in camera space -> world space)
    vec3 ro = (invView * vec4(0, 0, 0, 1)).xyz;
    // Ray direction (rdCam in camera space -> world direction)
    vec3 rd = normalize((invView * vec4(rdCam, 0)).xyz);

    // Raymarch the scene
    RaymarchResult res;
    res.hit = false;
    for(int i = 0; i < NUM_SPHERES; i++) {
        RaymarchResult thisRes = raymarchSphere(spheres[i], ro, rd);

        if(thisRes.hit && (!res.hit || thisRes.tHit < res.tHit)) {
            res = thisRes;
        }
    }

    for(int i = 0; i < NUM_CUBES; i++) {
        RaymarchResult thisRes = raymarchCube(cubes[i], ro, rd);

        if(thisRes.hit && (!res.hit || thisRes.tHit < res.tHit)) {
            res = thisRes;
        }
    }

    vec4 color;
    if(res.hit) {
        for(int i = 0; i < NUM_LIGHTS; i++) {
            color += calculateLightColor(res, lights[i]);
        }
    } else {
        color = vec4(0.0, 0.0, 0.0, 1.0);
    }

    // Write the pixel color to the output image
    imageStore(outImage, pix, color);
}
